# 基础

## 1. 前端需要注意哪些SEO
- 合理的 <font color=red size=4>title</font> 、 <font color=red size=4>description</font> 、 <font color=red size=4>keywords</font> ：搜索对着三项的权重逐个减小，`title`值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面 `title` 要有所不同；`description`把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面`description` 有所不同； `keywords` 列举出重要关键词即可
- 语义化的 HTML 代码，符合W3C规范：语义化代码让搜索引擎容易理解网页
- 重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下， 有的搜索引擎对抓取长度有限制，保证重要内容⼀定会被抓取
- 重要内容不要用 js 输出：爬虫不会执行js获取内容
- 少用 iframe ：搜索引擎不会抓取 iframe 中的内容
- ⾮装饰性图片必须加 alt
- 提高网站速度： 网站速度是搜索引擎排序的⼀个重要指标
## 2. <font color=red size=5>`<img/>`</font>的 <font color=red size=5>title</font> 和 <font color=red size=5>alt</font> 有什么区别?
- 通常当鼠标滑动到元素上的时候显示
- alt 是 `<img>`的特有属性，是图片内容的等价描述，用于图片⽆法加载时显示、读屏器阅读图片 。可提图片高可访问性， 除了纯装饰图片外都必须设置有意义的值， 搜索引擎会重点分析。
## 3. 如何进行网站性能优化

- content 方面
  1. 减少`Http`请求：合并文件、CSS精灵图、inline Image
  2. 减少`DNS`查询：DNS缓存，将资源分布到恰当数量的主机名
  3. 减少`DOM`元素数量

- Server 方面
  1. 使用CDN
  2. 配置ETag
  3. 对组件使用Gzip压缩

- Cookie 方面
  1. 减少 cooike 大小

- CSS 方面
  1. 将样式表放在页面顶部
  2. 不使用CSS表达式
  3. 使用`<link>`不使用`@import`

- Javascript 方面
  1. 将脚本放到页面底部
  2. 将`JavaScript`和`CSS`从外部引入
  3. 压缩`JavaScript`和`CSS`
  4. 删除不需要的脚本
  5. 减少DOM访问

- 图片 方面
  1. 优化图片：根据实际颜色需要选择色深、压缩
  2. 优化css精灵
  3. 不要在HTML中拉伸图片

## 4. HTML5有哪些新特性
> HTML5主要新增关于图像、位置、存储、多任务等功能的增加
- 绘画 `Canvas`
- 用于媒体回访的`video`和`audio`元素
- 本地离线存储`localStorage`长期存储数据，浏览器关闭后不会丢失
- `sessionStorage`的数据在浏览器关闭后自动删除
- 语义化更好的内容元素，比如：`article`、`footer`、`header`、`nav`、`section`
- 表单控件，`calendar`、`date`、`time`、`email`、`url`、`search`
- 新的技术`webworker`、`websocket`、`geo location`


## 5. 请描述一下<font color=red size=5>cookie</font>，<font color=red size=5>sessionStorage</font>和<font color=red size=5>localStorage</font>的区别
- `cookie`是网站为了标识用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）
- `cookie`数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器端间来回传递
- `sessionStorage`和`localStorage`不会自动把数据发给服务器，仅在本地保存
- 存储大小：
  1. `cookie`数据大小不能超过4K
  2. `sessionStorage`和`localStorage`虽然也有存储大小的限制，但比`cookie`大得多，可以达到5M或者更大
- 有效时间：
  - `localStorage` 存储持久数据，浏览器关闭后数据不丢失，除非主动删除数据
  - `sessionStorage` 数据在当前浏览器窗口关闭后自动删除
  - `cookie`设置的`cookie`过期时间之前一直有效，即使窗口或者浏览器关闭 

## 6. iframe有哪些缺点
- `iframe`会阻塞主页面的`Onload`事件
- 搜索引擎的检索程序无法解读这种页面，不利于`SEO`
- `iframe`和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载
- 使用`iframe`之前需要考虑这两个确定。如果需要使用`iframe`，最好是通过`javascript`动态给`iframe`添加`src`属性值，这样可以绕开以上两个问题。

## 7. 行内元素、块级元素有哪些？有什么区别？
- 行内元素：<font color=red>a b span strong</font>
- 行内块级元素: <font color=red>img input select button textarea</font>
- 块级元素有：<font color=red>div ul ol li dl dt dd h1 h2 h3 h4... p section</font>
- 空元素有：<font color=red>input br hr img meta link</font>
- 行内元素不可以设置宽高，不独占一行，且外边距（margin）和内边距（padding）仅设置左右方向有效而上下无效
- 行内块级元素可以设置宽高，不独占一行，外边距（margin）和内边距（padding）有效
- 块级元素可以设置宽高，独占一行，外边距（margin）和内边距（padding）有效

> 内联元素则是根据其自身的内容或子元素来决定其宽度

## 8. HTML全局属性（global attribute）有哪些
- `class`: 元素设置类标识
- `data-*`：元素增加自定义属性
- `draggable`：设置元素是否可拖拽
- `id`：元素`id`，文档内唯一
- `lang`：元素内容的语言
- `style`：行内`css`样式
- `title`：元素相关的建议信息

## 9. Canvas和SVG有什么区别
- svg绘制出来的每一个图像的元素都是独立的`dom`节点，能够方便的绑定事件或用来修改，canvas输出的是一整幅画布
- svg输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会失真和锯齿，而canvas输出标量画布，就像是一张图片一样，放大会失真或者锯齿。

## 10. 网站验证码是为了解决什么安全问题
- 区分用户是计算机还是人的公共全自动程序。可以防止恶意破坏密码、刷票、论坛灌水。
- 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登录尝试。


## 11. viewport
```js
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```
1. `width`: 设置`viewport`宽度，为一个正整数，或字符串'device-width'
2. `device-width`: 设备宽度
3. `height`: 设置`viewport`高度，一般设置了宽度，自动解析出高度，可以不设置
4. `initial-scale` 默认缩放比例（初始缩放比例），为一个数字，可以带小数
5. `minimum-scale` 允许用户最小缩放比例，为一个数字，可以带小数
6. `maximum-scale` 允许用户最大缩放比例，为一个数字，可以带小数
7. `user-scalable` 是否允许手动缩放
8. `<meta name="description" content="不超过150个字符"/> <!--页面描述-->`
9. `<meta name="keywords" content="博客，前端，日志"/> <!-- 页面关键词-->`

> 如何处理移动端`1px` 被渲染成 `2px` 的问题
- 局部处理
  1. `meta `标签中的`viewport`属性, `initial-scale`设置为`1` 
  2. `rem`按照设计稿标准编写，外加利用`CSS`的`transform`的`scale(0.5)`缩小一倍

- 全局处理
  1. `meta `标签中的`viewport`属性, `initial-scale`设置为`0.5` 
  2. `rem`按照设计稿标准编写

## 12. 简述一下src和href的区别
- src用于替换当前元素，href用于在当前文档和引用资源之间确认联系
- src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前所在位置，在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素
- `<script src="dome.js"></script>`当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕。图片和框架等元素也如此，类似于将所指向资源嵌入当前的标签内。这也是为什么将js脚本放到底部而不是头部
- `href`是`Hypertext Reference`的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加`<link href="common.css" rel="stylesheet" /> `那么浏览器会识别该文档为`css`文档，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用`link`方式来加载`css`，而不是使用`@import`

## 13. display: none;、visibility: hidden;和opacity: 0;有什么不同
> 在Web开发中，display: none;、visibility: hidden;和opacity: 0;都是用来控制元素的显示状态，但它们的行为和效果有所不同;
- `display: none;`
  1. 行为：完全移除元素，使其在页面布局中不存在。其他元素会填补这个位置，就好像这个元素从未存在过。
  2. 占用空间：不占用任何空间。
  3. 事件响应：元素不可见且不会响应用户的任何事件（如点击、鼠标移动等）。
  4. 重绘和重排：会触发重排（reflow），因为移除了元素会影响其他元素的布局。
- `visibility: hidden;`
  1. 行为：元素仍然存在于页面布局中，但对用户不可见。
  2. 占用空间：继续占用空间，其位置和大小保持不变。
  3. 事件响应：元素不可见且不会响应用户的任何事件（如点击、鼠标移动等）。
  4. 重绘和重排：只会触发重绘（repaint），不会影响页面布局。
- `opacity: 0;`
  1. 行为：元素完全透明，对用户不可见，但仍然存在。
  2. 占用空间：继续占用空间，其位置和大小保持不变。
  3. 事件响应：元素透明但仍会响应用户的事件（如点击、鼠标移动等）。
  4. 重绘和重排：只会触发重绘（repaint），不会影响页面布局。

## 14. 如何创建块级格式化上下文(block formatting context)，BFC有什么用？
- 创建规则：
  1. 根元素
  2. 浮动元素（float 取值不为 none）
  3. 绝对定位元素（position取值为absolute 或者 fixed）
  4. `display` 取值为 `inline-block`、`table-cell`，`table-caption`、`flex`、`inline-flex`，`grid`，`inline-grid`之一的元素
  5. `overflow`取值为`hidden、auto、scroll`
- 作用
  1. 可以包含浮动元素
  2. 不被浮动元素覆盖
  3. 阻止父子元素的`margin`折叠

## 15. CSS3有哪些新特性?
- 新增各种`css`选择器
- 圆角 `border-radius`
- 多列布局
- 阴影和反射
- 文字特效`tex-shadow`
- 线性渐变
- 旋转`transform`


## 16. 介绍一下标准的CSS的盒子模型
- IE (怪异)模型，W3C盒子模型
- 盒模型：内容（content）、填充（padding）、外边距（margin）、边框（border）
- 区别：IE的content部分把 （border）+ (padding) 也算入

## 17. ::before 和 :after中双冒号和单冒号 有什么区别？解释⼀下这2个伪元素的作用?
- 单冒号(:)用于CSS3的伪类，双冒号(::)用于CSS3伪元素
- 用于区分伪类和伪元素

## 18. 如果需要手动写动画，你认为最小时间间隔是多久
- 大多数显示器的默认频率是60Hz，即1秒钟刷新60次，所以理论上最小间隔为（1/60*1000ms）~= 16.7ms

## 19. 什么是外边距重叠？重叠的结果是什么？
> 外边距重叠就是`margin-collapse`
- 在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距
#### 折叠结果遵循下列计算规则
1. 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。
2. 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。
3. 两个外边距一正一负时，折叠结果是两者的相加的和。

## 20. rgba()和opacity的透明效果有什么不同？
- `rgba(r, g, b, a)` 和`opacity`都能实现透明效果，但最大的不同是`opacity`作用于元素，以及元素内的所有内容的透明度。
- 而`rgba(r, g, b, a)`只作用于元素的颜色或其背景色。（设置rgba透明的元素的子元素不会继承透明效果！）

## 21. css有个content属性，有什么作用？
> css的content属性专门应用在before/after伪元素上，用于来插入生成内容。最常见的应用是利用伪类，清除浮动。

```css
.clearfix::after {
  content: '.';
  display: block;
  height: 0;
  visibility: hidden;
  clear: both
}
.clearfix {
  zoom: 1
}
```
## 22. 水平居中的方法
- 元素是行内元素，设置父元素`text-align: center`
- 如果元素宽度固定，可以设置左右`margin: auto`
- 如果元素为绝对定位，设置父元素`position: relative`，元素设：`left: 0; right: 0; margin: auto`
- 使用`flex-box`布局，指定`justify-content: center`
- `display`设置为`tabel-ceil`

## 23. 垂直居中的方法
- 将显示方式设置为表格， `display: table-cell`, 同时设置`vertial-align: middle`
- 使用flex布局，设置为`align-items: center`
- 绝对定位中设置`bottom: 0; top: 0`, 并且设置`margin: auto`
- 绝对定位中固定高度时设置`top: 50%; margin-top: 1/2 * ${height}`
- 文本垂直居中设置`line-height: ${height}`

## 24. 常用的垂直水平居中如下

```html
<div class="parent">
  <div class="children"></div>
</div>
```
#### 方式1：父子定位，transform结合translate
```css
// 方式1 
.parent {
  position: relative;
}
.children {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%)
}
```

#### 方式2： flex-box布局
```css
// 方式2
.parent {
  display: flex;
  justify-content: center;
  align-items: center;
}
```

## 25. 重绘和回流（重排）是什么？如何避免？
- DOM的变化影响到了元素的几何属性（宽高），浏览器重新计算元素的几何属性，其他元素的几何
- 属性和位置也会受到影响，浏览器需要重新构造渲染树，这个过程称为重排，浏览器将受到影响的部分
- 重新绘制到屏幕上的过程称为重绘。
  
引起重排的原因有：
  1. 添加或者删除可见的DOM元素
  2. 元素位置、尺寸、内容改变
  3. 浏览器页面初始化
  4. 浏览器窗口尺寸改变，重排一定重绘，重绘不一定重排。
  
减少重绘和重排的方法：
  1. 不在布局信息改变时做DOM查询
  2. 使用`cssText` 或者 `className`一次性改变属性
  3. 使用`fragment`
  4. 对于多次重排的元素，如动画，使用绝对定位脱离文档流，让它的改变不影响到其他元素

## 26. 如何实现小于12px的字体效果
- 给元素添加一个可以设置宽高的属性，比如：`display: inline-block`或者`display: flex`，且通过css的属性`transform: scale(0.5)`来缩放进行实现。


## 27. 闭包
#### 闭包的关键特性
1. 函数的嵌套
2. 外部函数的返回值是内部函数
3. 内部函数可以访问外部函数中的变量，即使外部函数已经执行完毕。

#### 闭包的特点
1. 持久化变量：闭包可以记住并持有其词法环境中的变量，即使外部函数已经执行完毕
2. 封装性：闭包可以帮助封装数据，不被外部直接访问
3. 词法作用域：闭包能够记住它所在的词法作用域

#### 闭包的用处
- 读取函数内部的变量
- 让函数内部的变量始终保存在内存中
- 好处：能够实现封装和缓存等
- 坏处：消耗内存，不正当使用会造成内存溢出的问题

#### 闭包的注意点
- 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，也会导致内存泄漏
- 在推出函数之前，将不适用的局部变量清除
- fn = null

```
// 示例1 计数器
function makeCounter(num) {
  let count = 0
  
  return function() {
    conut += 1
    return count
  }
}
```

## 28. 作用域链
- 作用域链的作用是保证执行环境里有权访问的变量和函数都是有序的，作用域链的变量只能向上访问，变量访问到`window`对象即可，作用域链向下访问变量是不被允许的
- 简单来说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期

## 29. 什么是事件代理
- 事件代理（Event Delegation），又称之为事件委托。是`Javascript`中常用绑定事件的常用技巧。顾名思义，`事件代理`即是把原本需要绑定的事件委托给父元素,让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡，使用事件代理的好处是可以提高性能
- 可以大量节省内存占用，减少事件注册。
- 可以实现当新增子对象时候无需再次对其绑定事件

#### 事件代理的例子
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>事件委托</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      ul {
        margin: 20px;
      }
      li {
        list-style: none;
        cursor: pointer;
      }
      li:nth-of-type(2n) {
        background-color: skyblue;
      }
      li:nth-of-type(2n + 1) {
        background-color: palegoldenrod;
      }
    </style>
  </head>
  <body>
    <ul class="ul" id="ul">
      <li>1</li>
      <li>2</li>
      <li>3</li>
      <li>4</li>
      <li>5</li>
      <li>6</li>
    </ul>

    <script>
      const ulEl = document.getElementById("ul");
      let list = document.querySelectorAll("li");
      console.log(list, "list");
      ulEl.addEventListener("click", (e) => {
        const target = e.target;
        console.log(target, 'target')
        for (let i = 0; i < list.length; i++) {
          const el = list[i];
          if(el === target) {
            console.log(`点击第${i+1}个li，内容是${target.innerHTML}`)
          }
        }
      });
      for (let index = 0; index < 5; index++) {
        const li = document.createElement('li')
        li.innerHTML = list.length + index + 1
        ulEl.appendChild(li)
        // list = document.querySelectorAll("li");
      }
    </script>
  </body>
</html>

```